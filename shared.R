# This file was generated by project setup to hold shared variables for project Eduzměna – první vlna.
# It is loaded by default by each RMarkdown file created using reschola's templates.
# You should add all variables needed in multiple scripts here.

# Do not add passwords, API keys and other information that should not be made public.

# Store those in .Renviron. usethis::edit_r_environ() opens it for you for editing.
project_title <- "Eduzměna – první vlna"
gd_url <- "https://drive.google.com/drive/u/1/folders/1L4lxXbit5nbMbr98WGGn7TXDFffisGDV"



limesurvey_api <- "http://dotazniky.scholaempirica.org/limesurvey/index.php/admin/remotecontrol"

# limesurvey username
ls_cred <- function(type = "user") {
  if (!type %in% c("user", "pass", "reset")) {
    stop('Only "user", "pass" or "reset" values are allowed!', call. = FALSE)
  }
  if (type != "reset") {
    cred <- ifelse(type == "user", Sys.getenv("LS_USER"), Sys.getenv("LS_PASS"))
    if (nzchar(cred)) {
      message(
        "Using LimeSurvey ",
        switch(type,
               "user" = "username",
               "pass" = "password"
        ), " from .Renviron."
      )
      return(cred)
    } else {
      cred <- if (type == "user") {
        rstudioapi::showPrompt(
          "LimeSurvey username",
          "It seems you have no LimeSurvey username stored in .Renviron, please enter it here."
        )
      } else {
        rstudioapi::askForPassword("LimeSurvey password")
      }
      ifelse(type == "user", Sys.setenv(LS_USER = cred), Sys.setenv(LS_PASS = cred))
      message(
        "Your LimeSurvey ",
        switch(type,
               "user" = "username",
               "pass" = "password"
        ), " should now be stored in .Renviron for further use."
      )
      return(cred)
    }
  } else {
    Sys.unsetenv("LS_USER")
    Sys.unsetenv("LS_PASS")
    message("Limesurvey credentials have been reset!")
  }
}

# GMAIL auth
gmail_cred <- function(type = c("user", "pass", "name", "reset")) {
  type <- rlang::arg_match(type)
  if (type != "reset") {
    cred <- switch(type,
                   "user" = Sys.getenv("GMAIL_USER"),
                   "pass" = Sys.getenv("GMAIL_PASS"),
                   "name" = Sys.getenv("GMAIL_NAME")
    )
    if (nzchar(cred)) {
      message(
        "Using Gmail/GSuite ",
        switch(type,
               "user" = "username",
               "pass" = "password",
               "name" = "name"
        ), " from .Renviron."
      )
      return(cred)
    } else {
      cred <- if (type == "user") {
        rstudioapi::showPrompt(
          "Gmail/GSuite email address",
          'It seems you have no Gmail/GSuite address (like "surname@scholaempirica.org"") stored in .Renviron, please enter it here.'
        )
      } else if (type == "pass") {
        rstudioapi::askForPassword("Gmail/GSuite password")
      } else {
        rstudioapi::showPrompt(
          "Gmail/GSuite name",
          'It seems you have no Gmail/GSuite name (the one that appears in email inbox, like "Name Surname") stored in .Renviron, please enter it here.'
        )
      }
      switch(type,
             "user" = Sys.setenv(GMAIL_USER = cred),
             "pass" = Sys.setenv(GMAIL_PASS = cred),
             "name" = Sys.setenv(GMAIL_NAME = cred)
      )
      message(
        "Your Gmail/GSuite ",
        switch(type,
               "user" = "username",
               "pass" = "password",
               "name" = "name"
        ), " should now be stored in .Renviron for further use."
      )
      return(cred)
    }
  } else {
    Sys.unsetenv("GMAIL_USER")
    Sys.unsetenv("GMAIL_PASS")
    Sys.unsetenv("GMAIL_NAME")
    message("Gmail/GSuite credentials have been reset!")
  }
}

# remove rows empty at specified cols function, returning all cols
remove_empty_at <- function(df, vars) {
  selection <- df %>% select({{ vars }})
  keep_mask <- rowSums(is.na(selection)) != ncol(selection)
  return(df[keep_mask, , drop = FALSE])
}

# better compilation function - auto saves all files in project and if everything OK, opens up the report in Word
compile_and_open <-
  function(report, open_success = TRUE, output_dir = 'reports-output', ...) {
    result <- tryCatch({
      {
        if (rstudioapi::isAvailable()) {
          rstudioapi::documentSaveAll()
          rstudioapi::executeCommand("activateConsole")
        }
        rmarkdown::render(report, output_dir = output_dir, ...)
      }
    }, error = function(e) {
      message(
        "ERROR: Report compilation failed with message:\n----------------------------------------------"
      )
      message(e)
      return("fail")
    })

    if (result != "fail" & open_success == TRUE) {
      system2("open", result)
    } else if (result == "fail" & open_success == TRUE) {
      message("Compilation failed, nothing to open!")
    } else {
      message("If you want the successufuly compiled report(s)\nto open automatically, please state it with\n'open_success = TRUE' argument.")
    }
  }

# wrong IDs detection
if (packageVersion("dplyr") < 1) {
  spot_weirdos <- function(df, id, var, type) {
    id <- enquo(id)
    var <- enquo(var)

    if (type %in% c("unique", "u")) {
      df %>%
        group_by(!!id) %>%
        summarise(n = n_distinct(!!var, na.rm = T)) %>%
        filter(n > 1) %>%
        pull(!!id) %>%
        unique
    } else if (type %in% c("nonrepeating", "nr")) {
      df %>%
        filter(!is.na(!!var)) %>%
        count(!!id, !!var) %>%
        filter(n > 1) %>%
        pull(!!id) %>%
        unique
    }
  }
} else {
  # wrong IDs detection for dplyr 1++++
  spot_weirdos <- function(df, id, var, type) {
    id <- enquo(id)
    var <- enquo(var)

    if (type %in% c("unique", "u")) {
      df %>%
        group_by(!!id) %>%
        summarise(across(!!var, dplyr::n_distinct, na.rm = T)) %>%
        filter(!!var > 1) %>%
        pull(!!id) %>%
        unique
    } else if (type %in% c("nonrepeating", "nr")) {
      df %>%
        filter(!is.na(!!var)) %>%
        count(!!id, !!var) %>%
        filter(n > 1) %>%
        pull(!!id) %>%
        unique
    }
  }
}

# "superagers" detection
spot_superagers <- function(df, id, date_var, var) {
  id <- enquo(id)
  date_var <- enquo(date_var)
  var <- enquo(var)

  df %>% group_by(!!id) %>%
    arrange(!!date_var) %>%
    nest() %>%
    mutate(invalid = map(.x = data, .f = ~ diff(eval(
      parse(text = paste0(".x$", quo_name(var)))
    )))) %>%
    select(-data) %>%
    unnest(invalid) %>%
    filter(invalid > 1) %>%
    pull(!!id)
}

# -------------------------------------------------------------------------
# kill any messaging wrapped in this fction
quiet <- function(x) {
  sink(tempfile())
  on.exit(sink())
  invisible(force(x))
}


# mark fct level as NA ----------------------------------------------------
fct_nanify <- function(f, nanify) {
  f[f == nanify] <- NA
  f
}

drop_dontknow <- function(f, nanify) {
  nanified <- f %>% fct_nanify(nanify) %>% as.integer
  nanified <- nanified - 1 # subtract 1 to ger rid of dontknow category
  nanified
}

# x, y labeling -----------------------------------------------------------
get_labs <- function(vars,
                     wrap = NULL,
                     labs_list = item_labs_list) {
  pos <- tidyselect::eval_select(rlang::expr(all_of(c(vars))), data = labs_list)
  out <- labs_list[c(pos)] %>% unlist()
  if (!is.null(wrap)) {
    out <- out %>% stringr::str_wrap(wrap)
  }
  return(out)
  rlang::warn("`get_labs` is soft-deprecated. Outside plot construction,\nuse `tidy_labs` which supports tidyselect syntax.", .frequency = "once", .frequency_id = "get_labs_deprec")
}

tidy_labs <- function(..., wrap = NULL,
                      labs_list = item_labs_list) {
  expr <- rlang::expr(c(...))
  pos <- tidyselect::eval_select(expr, data = labs_list)
  out <- labs_list[c(pos)] %>% unlist()
  if (!is.null(wrap)) {
    out <- out %>% stringr::str_wrap(wrap)
  }
  return(out)
  rlang::inform("Note:\n`tidy_labs` supports tidyselect syntax.\nFor safety reasons, when you specify the `wrap`\nor `item_list` args, name them explicitly.", .frequency = "once", .frequency_id = "tidy_labs_info")
}

# facet labelling ---------------------------------------------------------
# this function have to be CALLED inside facets as labeller argument!!!
# it acts in the very simillar way as get_labs() which is called inside this labeller
# arguments of the labeller are the same as in get_labs(), but variable codes cannot be selected by user

schola_labeller <- function(wrap = 40, labs_list = item_labs_list, multi_line = TRUE) {
  fun <- function(labels) {
    labels <- label_value(labels, multi_line = multi_line)
    lapply(labels, function(x) {
      get_labs(vars = dplyr::all_of(x), wrap = wrap, labs_list = labs_list)
    })
  }
  structure(fun, class = "labeller")
}


# quick color palette with NA setup ---------------------------------------

# deprecated ------------------
# clrs <- function(n, na_pos = c("first", "last", "none"), na_col = "darkgray") {
#   na_pos <- rlang::arg_match(na_pos)
#
#   pal <- RColorBrewer::brewer.pal(n = n - 1, name = "RdYlBu")
#
#   switch(na_pos,
#     "first" = return(c(na_col, pal)),
#     "last" = return(c(pal, na_col)),
#     return(pal)
#   )
# }
# -----------------------------

# custom fill scale using schola palette
scale_fill_schola <- function(..., type = "div",
                              palette = "RdYlBu",
                              direction = 1,
                              na_pos = c("first", "last", "none"),
                              na_col = "darkgray",
                              drop = FALSE, # show unused levels
                              aesthetics = "fill") {
  na_pos <- rlang::arg_match(na_pos)

  ggplot2::discrete_scale(aesthetics, "schola_scale", schola_pal(
    type, palette,
    direction, na_pos, na_col
  ), drop = drop, ...)
}

# the palette (based on RColorBrewer)
schola_pal <- function(type = "seq", palette = 1, direction = 1,
                       na_pos = c("first", "last", "none"),
                       na_col = "darkgray") {
  pal <- scales:::pal_name(palette, type)
  force(direction)
  na_pos <- rlang::arg_match(na_pos)
  function(n) {
    pal <- suppressWarnings(
      RColorBrewer::brewer.pal(ifelse(na_pos %in% c("first", "last"), n - 1, n), pal)
    )
    if (direction == -1) {
      pal <- rev(pal)
    }
    switch(na_pos,
           "first" = return(c(na_col, pal)),
           "last" = return(c(pal, na_col)),
           "none" = return(pal)
    )
  }
}

# expand and relevel...  ------------------------------------------------------

fct_exprel <- function(f, ...) {
  expanded <- forcats::fct_expand(f, ...)
  forcats::fct_relevel(expanded, ...)
}



# czech dates declension -------------------------------------------------

month_czech <- function(month, case = c("nominative", "locative", "genitive")) {
  declensed <- switch(match.arg(case),
                      "nominative" = c(
                        "leden", "únor", "březen", "duben", "květen", "červen", "červenec", "srpen", "září", "říjen", "listopad", "prosinec"
                      ),
                      "locative" = c(
                        "lednu", "únoru", "březnu", "dubnu", "květnu", "červnu", "červenci", "srpnu", "září", "říjnu", "listopadu", "prosinci"
                      ),
                      "genitive" = c(
                        "ledna", "února", "března", "dubna", "května", "června", "července", "srpna", "září", "října", "listopadu", "prosince"
                      )
  )

  month <- month(month)
  declensed[month]
}


interval_print <- function(x, y) {
  days <- unique(day(c(x, y)))
  months <- unique(month(c(x, y)))
  years <- unique(year(c(x, y)))

  if (length(days) != 1 & length(months) == 1 & length(years) == 1) {
    paste0(days[1], ".–", days[2], ". ", month_czech(months[1], "gen"), " ", years[1])
  } else if (length(days) != 1 & length(months) != 1 & length(years) == 1) {
    paste0(days[1], ". ", month_czech(months[1], "gen"), " – ", days[2], ". ", month_czech(months[2], "gen"), " ", years[1])
  } else if (length(days) != 1 & length(months) != 1 & length(years) != 1) {
    paste0(days[1], ". ", month_czech(months[1], "gen"), " ", years[1], " – ", days[2], ". ", month_czech(months[2], "gen"), " ", years[2])
  } else if (length(days) == 1 & length(months) != 1 & length(years) == 1) {
    paste0(days[1], ". ", month_czech(months[1], "gen"), " – ", days[1], ". ", month_czech(months[2], "gen"), " ", years[1])
  } else {
    stop("Maturing lifecycle, case not yet defined...")
  }
}
